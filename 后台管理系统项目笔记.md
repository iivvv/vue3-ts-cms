# Vue3-ts-cms

# （初始化：）

## 一、项目介绍

### 1.1. 后台管理系统的定位和核心

核心：数据库 增删改查

### 1.2. 后台管理系统项目功能介绍

![image-20230508162905140](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230508162905140.png)

pinia和ts的结合比vuex更方便

AntDesign官方没有vue版本，但是社区有人做了AntDesignVue，不过最常用的还是Element Plus



高级组件封装，页面配置？



### 1.3. 创建vue项目

方法一：vue-cli基于webpack和node

✅方法二：create-vue（官方最新推荐）基于vite工具和node



![image-20230509151242101](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230509151242101.png)

favicon.ico

标题

环境插件volar、![image-20230509152217406](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230509152217406.png)



### 1.4. 文件目录介绍

配置文件介绍



### 1.5. tsconfig文件的作用和解析





#### .vue文件声明

import组件时，组件为 DefineComponent类型

![image-20230509144509000](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230509144509000.png)

使用volar插件后可以不用自己写声明







## 二、配置代码规范

### 2.1. 集成editorconfig配置编码风格

EditorConfig 有助于为**不同 IDE** 编辑器上处理同一项目的多个开发人员维护一致的编码风格。

```yaml
# http://editorconfig.org

root = true

[*] # 表示所有文件适用
charset = utf-8 # 设置文件字符集为 utf-8
indent_style = space # 缩进风格（tab | space）
indent_size = 2 # 缩进大小
end_of_line = lf # 控制换行类型(lf | cr | crlf)
trim_trailing_whitespace = true # 去除行尾的任意空白字符
insert_final_newline = true # 始终在文件末尾插入一个新行

[*.md] # 表示仅 md 文件适用以下规则
max_line_length = off
trim_trailing_whitespace = false
```

VSCode需要安装一个插件：EditorConfig for VS Code



### 2.2. 使用prettier工具格式化代码

Prettier 是一款强大的**代码格式化**工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。

1.安装prettier

```shell
npm install prettier -D
```

2.配置.prettierrc.json文件：(.json可以省略)

* useTabs：使用tab缩进还是空格缩进，选择false；
* tabWidth：tab是空格的情况下，是几个空格，选择2个；
* printWidth：当行字符的长度，推荐80，也有人喜欢100或者120；
* singleQuote：使用单引号还是双引号，选择true，使用单引号；
* trailingComma：在多行输入的尾逗号是否添加，设置为 `none`，比如对象类型的最后一个属性后面是否加一个，；
* semi：语句末尾是否要加分号，默认值true，选择false表示不加；

```json
{
  "useTabs": false,
  "tabWidth": 2,
  "printWidth": 80,
  "singleQuote": true,
  "trailingComma": "none",
  "semi": false
}
```



3.创建.prettierignore忽略文件

```
/dist/*
.local
.output.js
/node_modules/**

**/*.svg
**/*.sh

/public/*
```



4.VSCode需要安装prettier的插件

![image-20210722214543454](https://tva1.sinaimg.cn/large/008i3skNgy1gsq2acx21rj30ow057mxp.jpg)



5.VSCod中的配置

- settings =>format on save => 勾选上
- settings => editor default format => 选择 prettier

![1665644883500](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1665644883500.png)



6.测试prettier是否生效

* 测试一：在代码中保存代码；
* 测试二：配置一次性修改的命令；

在package.json中配置一个scripts：

```json
    "prettier": "prettier --write ."
```



### 2.3. 使用ESLint检测不规范代码

1.在前面创建项目的时候，我们就选择了ESLint，所以Vue会默认帮助我们配置需要的ESLint环境。

2.VSCode需要安装ESLint插件：

![image-20210722215933360](https://tva1.sinaimg.cn/large/008i3skNgy1gsq2oq26odj30pw05faaq.jpg)

**3.解决eslint和prettier冲突的问题：**

安装插件：（vue在创建项目时，如果选择prettier，那么这两个插件会自动安装）

```shell
npm install eslint-plugin-prettier eslint-config-prettier -D
```

添加prettier插件：

```json
>.eslintrc.cjs

'extends': [
    "plugin:vue/vue3-essential",
    "eslint:recommended",
    "@vue/eslint-config-typescript",
    "@vue/eslint-config-prettier",
    "plugin:prettier/recommended" //这里
  ],
```



4.VSCode中eslint的配置

```json
  "eslint.lintTask.enable": true,
  "eslint.alwaysShowStatus": true,
  "eslint.validate": [
    "javascript",
    "javascriptreact",
    "typescript",
    "typescriptreact"
  ],
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
```

5.当希望关闭某一条eslint警告时：

手动在.eslintrc.cjs中添加

```json
rules:{
  "xxxxxx":'off'
}
```

### ——————————

### 1.4. git Husky和eslint（后续）

虽然我们已经要求项目使用eslint了，但是不能保证组员提交代码之前都将eslint中的问题解决掉了：

* 也就是我们希望保证代码仓库中的代码都是符合eslint规范的；

* 那么我们需要在组员执行 `git commit ` 命令的时候对其进行校验，如果不符合eslint规范，那么自动通过规范进行修复；

那么如何做到这一点呢？可以通过Husky工具：

* husky是一个git hook工具，可以帮助我们触发git提交的各个阶段：pre-commit、commit-msg、pre-push

如何使用husky呢？

这里我们可以使用自动配置命令：

```shell
npx husky-init && npm install
```

这里会做三件事：

1.安装husky相关的依赖：

![image-20210723112648927](https://tva1.sinaimg.cn/large/008i3skNgy1gsqq0o5jxmj30bb04qwen.jpg)

2.在项目目录下创建 `.husky` 文件夹：

![image-20210723112719634](https://tva1.sinaimg.cn/large/008i3skNgy1gsqq16zo75j307703mt8m.jpg)

3.在package.json中添加一个脚本：

![image-20210723112817691](https://tva1.sinaimg.cn/large/008i3skNgy1gsqq26phpxj30dj06fgm3.jpg)

接下来，我们需要去完成一个操作：在进行commit时，执行lint脚本：

![image-20210723112932943](https://tva1.sinaimg.cn/large/008i3skNgy1gsqq3hn229j30nf04z74q.jpg)





这个时候我们执行git commit的时候会自动对代码进行lint校验。



### 1.5. git commit规范（后续）

#### 1.5.1. 代码提交风格

通常我们的git commit会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gsqw17gaqjj30to0cj3zp.jpg)

但是如果每次手动来编写这些是比较麻烦的事情，我们可以使用一个工具：Commitizen

* Commitizen 是一个帮助我们编写规范 commit message 的工具；

1.安装Commitizen

```shell
npm install commitizen -D
```

2.安装cz-conventional-changelog，并且初始化cz-conventional-changelog：

```shell
npx commitizen init cz-conventional-changelog --save-dev --save-exact
```

这个命令会帮助我们安装cz-conventional-changelog：

![image-20210723145249096](https://tva1.sinaimg.cn/large/008i3skNgy1gsqvz2odi4j30ek00zmx2.jpg)

并且在package.json中进行配置：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gsqvzftay5j30iu04k74d.jpg)

这个时候我们提交代码需要使用 `npx cz`：

* 第一步是选择type，本次更新的类型

| Type     | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| feat     | 新增特性 (feature)                                           |
| fix      | 修复 Bug(bug fix)                                            |
| docs     | 修改文档 (documentation)                                     |
| style    | 代码格式修改(white-space, formatting, missing semi colons, etc) |
| refactor | 代码重构(refactor)                                           |
| perf     | 改善性能(A code change that improves performance)            |
| test     | 测试(when adding missing tests)                              |
| build    | 变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等） |
| ci       | 更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等 |
| chore    | 变更构建流程或辅助工具(比如更改测试环境)                     |
| revert   | 代码回退                                                     |

* 第二步选择本次修改的范围（作用域）

![image-20210723150147510](https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8ca15oj30r600wmx4.jpg)

* 第三步选择提交的信息

![image-20210723150204780](https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8mq3zlj60ni01hmx402.jpg)

* 第四步提交详细的描述信息

![image-20210723150223287](https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8y05bjj30kt01fjrb.jpg)

* 第五步是否是一次重大的更改

![image-20210723150322122](https://tva1.sinaimg.cn/large/008i3skNgy1gsqw9z5vbij30bm00q744.jpg)

* 第六步是否影响某个open issue

![image-20210723150407822](https://tva1.sinaimg.cn/large/008i3skNgy1gsqwar8xp1j30fq00ya9x.jpg)

我们也可以在scripts中构建一个命令来执行 cz：

![image-20210723150526211](https://tva1.sinaimg.cn/large/008i3skNgy1gsqwc4gtkxj30e207174t.jpg)



#### 1.5.2. 代码提交验证

如果我们按照cz来规范了提交风格，但是依然有同事通过 `git commit` 按照不规范的格式提交应该怎么办呢？

* 我们可以通过commitlint来限制提交；

1.安装 @commitlint/config-conventional 和 @commitlint/cli

```shell
npm i @commitlint/config-conventional @commitlint/cli -D
```

2.在根目录创建commitlint.config.js文件，配置commitlint

```js
module.exports = {
  extends: ['@commitlint/config-conventional']
}
```

3.使用husky生成commit-msg文件，验证提交信息：

```shell
npx husky add .husky/commit-msg "npx --no-install commitlint --edit $1"
```





## 三. 项目内容搭建

### 3.1. 目录结构的创建

![image-20230510004442373](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230510004442373.png)



### 3.2. css样式的重置

Nomalize.css

reset.css

### 3.3. vue-router路由

https://router.vuejs.org/zh/introduction.html

安装

配置

创建页面组件时，使用【代码片段】可更快速便捷。 226 14分

https://snippet-generator.app/

main、login、notfound页面

测试

### 3.4. pinia状态管理

https://pinia.vuejs.org/zh/introduction.html

安装

配置文件src>store>index.ts

app.use(pinia)

测试是否成功



（隐式any设置



### 3.5. axios网络请求

直接复制之前的service文件（全项目通用）

测试

(视频里的接口好像失效了？)



### 3.6. 区分开发和生产环境

情景背景：axios请求中的base_url（或其他变量）在不同环境下值不一样，如何解决？

#### 方法一：手动打开注释修改地址（有风险）

```ts
// export const BASE_URL = 'http://coderwhy.dev:8000'
// export const BASE_URL = 'http://codercba.prod:8000'
```

上线时有人忘记改就糟了

#### 方法二：变量 import.meta.env.xxxx 

根据变量判断当前环境，返回不同的url地址

#### 方法三：环境目录 .env 

配置三个环境文件，写不同的地址





## 四. Element-Plus集成

https://element-plus.gitee.io/zh-CN/guide/quickstart.html

### 4.1. 全局引入

文件过大

### 4.2. 按需引入（推荐）

您需要使用额外的插件来导入要使用的组件。

#### 自动导入插件

首先需要安装`unplugin-vue-components` 和 `unplugin-auto-import`这两款插件

```
npm install -D unplugin-vue-components unplugin-auto-import
```

然后把下列代码插入到你的 `Vite` 或 `Webpack` 的配置文件中



### 4.3. 图标的引入

### 4.4. ElMessage引入



# （页面整体架构搭建：）

## 五. 搭建登录页面

![登录页](/Users/puluotagela/webfront/vue3-ts-cms/设计图/登录页.png)

### 5.1. 背景的搭建

* 100vw/vh

设置背景图片

### 5.2. 登录界面Panel

合理拆分子组件

#### 5.2.1. 整体界面的搭建

* 标题
* tabs组件
* 记住密码/忘记链接(checkbox、link组件)

* 立即登录(button组件)

#### 5.2.2. tabs搭建过程

* 给label增加图标

  有个label具名插槽

  icon图标组件(使用教程看文档)

  https://element-plus.gitee.io/zh-CN/component/icon.html#%E4%BD%BF%E7%94%A8%E5%9B%BE%E6%A0%87

  全局注册方便使用，自动导入有点麻烦且使用方法和示例不同



#### 5.2.3. 账号登录form input

- 使用form组件实现账号密码输入 

  此时代码过长，输入框可以再抽成一个子组件

* ElForm/ElFormItem/ElInput
* v-model绑定属性

```vue
<template>
  <div class="phone">
    <el-form :model="phone" label-width="60px" :rules="phoneRules">
      <el-form-item label="手机号" prop="phoneNum">
        <el-input v-model="phone.phoneNum" />
      </el-form-item>
      <el-form-item label="验证码" prop="code">
        <div class="verify-code">
          <el-input v-model="phone.code" />
          <el-button class="get-btn" type="primary">获取验证码</el-button>
        </div>
      </el-form-item>
    </el-form>
  </div>
</template>

<script setup lang="ts" name="phone">
import { reactive, ref } from 'vue'
// 定义内部的数据
const phone = reactive({
  phoneNum: '',
  code: ''
})
</script>
```





#### 5.2.4. form的校验规则

```ts
// 定义form的验证规则
const accountRules: FormRules = {
  name: [
    { required: true, message: '必须输入用户名~', trigger: 'blur' },
    {
      pattern: /^[a-z0-9]{6,20}$/,
      message: '必须是6~20个字母或数字',
      trigger: 'blur'
    }
  ],
  password: [
    { required: true, message: '必须输入密码~', trigger: 'blur' },
    { pattern: /^[a-z0-9]{3,}$/, message: '密码必须在3位以上', trigger: 'blur' }
  ]
}
```





#### 5.2.5. 点击立即登录

* 父组件发生点击, 执行子组件的函数.

  点击时让子组件打印帐号密码：父组件click事件，通过ref获取子组件实例 ，执行子组件实例中的login函数

  定义子组件实例变量时要给子组件类型，不然没有函数提示

  如何定义子组件类型？子组件类型组件构造器类型的实例类型：`ref<InstanceType<typeof PanelAccount>>`

  ```ts
  <panel-account ref="accountRef" />
  
  const accountRef = ref<InstanceType<typeof PanelAccount>>()
  function handleLogin() {
    console.log('立即登录')
    // accountRef.value?.loginAction(isKeep.value)
    accountRef.value?.loginAction(true)
  }
  ```

* defineExpose() 

  子组件得主动暴露，父组件才能调用

  ```vue
  defineExpose({
    loginAction
  })
  ```

  

### 5.3. 登录的操作

#### 5.3.1. 先判断账号密码是否通过form校验（格式校验）

- ref获取el-form实例，调用form组件的validate方法——formRef.validate(回调)

- 通过了继续登录

- 没通过则弹窗，使用message组件

  https://element-plus.gitee.io/zh-CN/component/message.html

#### 5.3.2. 登录接口的调用

* post

* data: {name, password}

  

coderwhy接口好像失效了

所以使用fastmock搭个虚拟接口：

https://www.fastmock.site/#/project/046c9a86f344ac3742b8411ee508e233



#### 5.3.3. 将登录操作写在store中



#### 5.3.4. IAccount类型的定义

account很多地方都要用到，需要把类型抽出来

1.放在第一次用数据的地方 

2.多处共用的话放types文件夹



#### 5.3.5 登录成功跳转到首页

` router.push('/main')`



### 5.4. postman的使用（接口失效 跳过



### 5.5. token缓存 常量

存到localstorage里

`const LOGIN_TOKEN = 'login/token'`

### 5.6. cache封装（通用）

```ts
enum CacheType {
  local = 'local',
  session = 'session'
}

class HYCache {
  storage: Storage

  constructor(type: CacheType) {
    this.storage = type === CacheType.local ? localStorage : sessionStorage
  }

  setCache(key: string, value: any) {
    this.storage.setItem(key, JSON.stringify(value))
  }

  getCache(key: string) {
    const value = this.storage.getItem(key)
    if (value) {
      return JSON.parse(value)
    }
  }

  deleteCache(key: string) {
    this.storage.removeItem(key)
  }

  clearCache() {
    this.storage.clear()
  }
}

const localCache = new HYCache(CacheType.local)
const sessionCache = new HYCache(CacheType.session)

export { localCache, sessionCache }

```

### 



### 5.7. 导航守卫 

```ts
router.beforeEach((to) => {
  // 只有登录成功(token), 才能真正进入到main页面
  const token = localCache.getCache(LOGIN_TOKEN)
  if (to.path.startsWith('/main') && !token) {
    return '/login'
  }
})
```



### 5.8. 退出登录、记住密码功能

点击删除token

跳回login页面

```ts
const router = useRouter()
function handleExitClick() {
  localCache.removeCache(LOGIN_TOKEN)
  router.push('/login')
}
```



```ts
// 2.记住密码
      if (isKeep) {
        localCache.setCache('name', name)
        localCache.setCache('password', password)
      } else {
        localCache.deleteCache('name')
        localCache.deleteCache('password')
      }
```







### 5.9. main权限管理

* RBAC: role based access control
  * 基于角色访问控制(权限管理)
  * 超级管理员、管理员、开发人员、运营人员、普通员工……
  * 根据不同的角色分配不同权限
* 后台数据库设计表(了解)





### 5.10. 请求用户信息

* 用户的角色

发送请求时携带token

```ts
const hyRequest = new HYRequest({
  baseURL: BASE_URL,
  timeout: TIME_OUT,

  interceptors: {
    requestSuccessFn: (config) => {
      const token = localCache.getCache(LOGIN_TOKEN)
      if (config.headers && token) {
        config.headers.Authorization = 'AAA' + token
      }

      return config
    }
  }
})
```



### 1.5. 根据角色id获取菜单信息

### 1.6. userInfo/userMenus进行本地缓存



## 六. 首页界面搭建

### 6.1. 整体的布局ElContainer

aside=logo + menu

### 6.2. 侧边栏的菜单Menu

#### 6.2.1. 分析ElMenu每一个组件的作用

 1.ElMenu
整个的菜单

2.el-sub-menu
可以有子菜单，并且是可以展开的

3.el-menu-item-group
对子菜单进行分组的，但是不能展开
目的是给小菜单加上组名称，但是不能交互

 4.el-menu-item
可以点击的每一个item

#### 6.2.2. 手动的搭建整个菜单结构

#### 6.2.3. 根据userMenus动态遍历

template控制循环

#### 6.2.4. 图标动态: 动态组件

把字符串转成组件，通过Component

`"el-icon-monitor" `   =>  `<el-icon><Monitor /><el-icon>`

```vue
 <el-icon>
      <component :is="item.icon.split('-icon-')[1]" />
 </el-icon>
```



### 6.3. 首页的头部Header展示

Menu折叠按钮——面包屑——图标按钮——用户头像名字

#### 6.3.1. menu-icon的图标点击折叠menu（细节丰富）

* 点击切换成另一个图标

  ```vue
  <el-icon size="28px">
     <component :is="isFold ? 'Expand' : 'Fold'" />
  </el-icon>
  
  import { ref } from 'vue'
  const isFold = ref(false)
  function handleMenuIconClick() {
    isFold.value = !isFold.value
  }
  ```

* 切换aside的宽度(动画)

  `<el-aside :width="isFold ? '60px' : '210px'">`

   ` transition: width 0.3s ease;`

* 切换menu的折叠效果

  子组件main-header.vue将isFold传给父组件main.vue    emit 

  父组件监听并传给兄弟组件main-menu     props

  兄弟组件main-menu切换collapse属性

  ```ts
  >>main-header.vue
  <div class="menu-icon" @click="handleMenuIconClick">
        <el-icon size="28px">
          <component :is="isFold ? 'Expand' : 'Fold'" />
        </el-icon>
  </div>
    
  const emit = defineEmits(['foldChange'])// 0.内部自定义事件
  const isFold = ref(false)// 1.记录状态
  function handleMenuIconClick() {
    isFold.value = !isFold.value// 1.内部改变状态
    emit('foldChange', isFold.value)// 2.将事件和状态传递给父组件
  }
  
  >>main.vue
  <el-aside :width="isFold ? '60px' : '210px'">
    <main-menu :is-fold="isFold" /> //父传子
  </el-aside>
  
     <main-header @fold-change="handleFoldChange" /> 
    
  const isFold = ref(false)
  function handleFoldChange(flag: boolean) {
    isFold.value = flag
  }
  ```

* 切换标题文字是否显示



#### 6.3.2. 三个图标按钮



#### 6.3.3. 个人信息下拉菜单

* dropdown组件

* avatar组件

* 退出登录

* 样式的调整

  ```css
  //因为下拉菜单会被渲染在app外，所以必须加 :global才能找到
  .info {
    :global(.el-dropdown-menu__item) { 
      line-height: 36px !important;
      padding: 6px 22px;
    }
  }
  
  // :deep 适用范围：父组件修改子组件里样式时使用，如果是子组件的根元素就可以不加
  ```

* Tmd element dropdown蓝色边框 

  ```css
  *:focus {
    outline: transparent auto 0px !important;
  }
  ```

  ![image-20230518032303292](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230518032303292.png)



### 6.4. 注册所有的路由, 页面跳转 （难点）

#### 方式一：手动注册所有路由（静态

router-view占位

创建所有子页面，配置二级路由映射

设置menu click事件实现点击跳转到页面

——注意：通过菜单进入路由有漏洞，手动输入路径也可以进入页面，会让没有权限（菜单上没有按钮）但知道路径的人进入不该被进入的页面

——应该使用动态路由：根据不同的角色的动态菜单，动态的注册路由



#### 方式二：动态路由



## 七. 首页menu——实现动态路由

### 7.1. 方案一：基于角色添加路由

```json
const roles={
 "superadmin"=
 "admin"=
 "manager"=
}
```

弊端：当新增角色时，需要重新增加key/value，需要前端修改这个roles json然后重新发布版本，或者后端组织好json数据给前端用

### 7.2. 方案二：基于菜单动态匹配（最合理）

菜单是动态展示，根据展示出来的菜单映射路由



### 7.3. 动态创建页面和路由对象

把所有路由都单独放在文件里，可以统一放在一个文件里，也可以每个路由单独一个文件（更方便使用一些自动化工具帮助创建）

动态引入`router.addRoute('xx',xx)`



coderwhy写了个工具，会在指定目录下创建文件夹+vue文件，还会在router文件夹下创建对应文件夹和路由对象

Mac 全局安装要加sudo `sudo npm i coderwhy -g`

使用示例：

`coderwhy add3page_setup department -d src/views/main/system/department`

- 用coderwhy把所有菜单页面和路由对象创建完






### 7.4. 根据菜单动态的映射路由（封装出来）

- 1.获取菜单（userMenus）

  store 登录时 获取并本地缓存了

- 2.动态加载路由对象，放到数组中localRoutes

  路由对象都在独立的文件中

  从文件中将所有路由对象先读取数组中

```ts
const localRoutes: RouteRecordRaw[] = []
const files: Record<string, any> = import.meta.glob(
  '../../router/main/**/*.ts',
  {
    eager: true //不需要按需引入懒加载
  }
)
for (const key in files) {
  const module = files[key]
  localRoutes.push(module.default)
}
```

https://blog.csdn.net/weixin_45172119/article/details/129233197



![image-20230519020500545](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230519020500545.png)

- 3.根据菜单去匹配正确的路由并添加到路由里

  （先观察数据特点），遍历，find（），根据url、path属性值判断是否有某个路由



router.addRoute('main', xxxx)

https://router.vuejs.org/zh/api/interfaces/Router.html#Methods-addRoute

- 封装出来

  

### 7.5. 刷新保持路由的注册状态

原因：刷新时重新加载，会不执行登录时的逻辑

所以需要刷新时重新映射加载动态路由

(草 bug出在了 有个变量不小心删了一个字母 还一直没发现)

```ts
>>store/login/login.ts 
loadLocalDataAction() {
      const token = localCache.getCache(LOGIN_TOKEN)
      const userInfo = localCache.getCache('userInfo')
      const userMenus = localCache.getCache('userMenus')
      if (token && userInfo && userMenus) {
        this.token = token
        this.userInfo = userInfo
        this.userMenus = userMenus

        // 2.动态添加路由
        const routes = mapMenuToRoutes(userMenus)
        routes.forEach((route) => router.addRoute('main', route))
      }
    }


>>store/index.ts
function registerStore(app: App<Element>) {
  // 1.use的pinia
  app.use(pinia)
  // 2.加载本地的数据
  const loginStore = useLoginStore()
  loginStore.loadLocalDataAction()
}
export default registerStore


>>main.ts
app.use(registerStore)
```





### 7.6. 登录后展示第一个页面

- 加载路由列表时，记录第一个页面

```ts
>>map-menus.ts
export let firstMenu: any = null
export function mapMenusToRoutes(userMenus: any[]) {
 	...
   if (!firstMenu && route) firstMenu = submenu
```

- 路由跳转到main时，跳转到第一个页面

  ```ts
  >>router/index.ts
  ...
  // 如果是进入到main
    if (to.path === '/main') {
      return firstMenu?.url
    }
  ```

  



### 7.7. 刷新页面匹配menu菜单

需要实现左侧menu根据当前地址路径来显示高亮

```ts
>>utils/map-menu.ts
//根据路径去匹配需要高亮显示的菜单
export function mapPathToMenu(menus: any[], path: string) {
  for (const menu of menus) {
    for (const submenu of menu.children) {
      if (path === submenu.url) return submenu
    }
  }
}

>>components/main-menu.vue
<el-menu
        :default-active="defaultValue"

const route = useRoute()
const currentMenu = mapPathToMenu(userMenus, route.path)
const defaultValue = ref<string>(currentMenu.id + '')


```



### 7.8. 面包屑的功能实现

breadcrumb组件：拿到数据，给组件展示

- 不能必须刷新才会更新，需要每次点击都更新，需要监听

watch / computed

- 一级路由取消设置单击跳转

别传对应地址



# （具体子页面搭建：）

## 八. 用户管理User界面

### 8.1. search搜索区域

- form表单组件

 el-input  

el-select 

el-datepicker

给表单使用layput布局组件



- 全局配置国际化

日期选择器改成中文 国际化

```vue
>>app.vue
<el-config-provider :locale="zhCn">
    <RouterView />
 </el-config-provider>


import zhCn from 'element-plus/dist/locale/zh-cn.mjs'

//为mjs文件声明新的模块 
>>env.d.ts
declare module '*.mjs'

```



- 重置按钮

重置方法1：获取form对象修改每条属性

重置方法2：使用`ref` `prop` `resetFields()`

```vue
 <el-form
      :model="userSearchForm"
      ref="formRef" //ref
      label-width="120px"
      size="large"
    >
      <el-row :gutter="20">
        <el-col :span="8">
          <el-form-item label="用户名" prop="name"> //prop
            <el-input
              v-model="userSearchForm.name"
              placeholder="请输入用户名"
            />
          </el-form-item>

import type { ElForm } from 'element-plus'

const formRef = ref<InstanceType<typeof ElForm>>()
function handleResetClick() {
  console.log(formRef.value)
  formRef.value?.resetFields()
}
```



### 8.2. content区域-header

header



### 8.3. content区域-table

#### 8.3.1 请求user列表数据

- 新建mock接口

![image-20230601150803244](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230601150803244.png)

- 封装请求

```ts
>>service/main/system/system.ts
import hyRequest from '@/service'

// 用户列表的网络请求
export function getUserListData() {
  return hyRequest.post({
    url: '/users/list',
    data: {
      offset: 0,
      size: 10
    }
  })
}
```



- 创建store/system文件夹 保存相关数据

定义systemstore类型

- 请求数据

需要给数据包裹响应式，不然直接使用的话会加载不出来，因为请求是异步的，第一次加载是没有结果的。

`const { usersList, usersTotalCount } = storeToRefs(systemStore)`

#### 8.3.2 用table展示数据

* el-table展示

* 自定义column

  选择` type='selection'`

  序号` type='index'`

  按钮 

#### 8.3.3 table样式设置



### 8.4. 自定义Table的Column

- 状态按钮 enable

​		作用域插槽 

* 时间格式化 createAt/updateAt 

  把`2021-01-02T10:20:26.000Z`转成`2021-01-02 18:20:26`

  dayjs封装utc转换

https://day.js.org/docs/zh-CN/plugin/utc

```ts
import dayjs from 'dayjs'
import utc from 'dayjs/plugin/utc'

dayjs.extend(utc)

export function utcFormat(utcString: string, format = 'YYYY-MM-DD HH:mm:ss') {
  return dayjs.utc(utcString).utcOffset(8).format(format)
}

```

```vue
 <el-table-column
          align="center"
          prop="createAt"
          label="创建时间"
          width="200"
        >
          <template #default="scope">
            {{ utcFormat(scope.row.createAt) }}
          </template>
  </el-table-column>
```



### 8.5. 分页器pagination组件展示





### 8.6. 分页器的页码改变 - 发送网络请求（后端接口问题，暂时无法实现）

根据每页条数和页码，重新获取数据并展示

（后端接口问题，暂时无法实现）





### 8.7. search区域的重置、查询

兄弟组件通讯，emit给父组件，父组件调用ref子组件事件，（没必要用事件总线）

重置数据——`resetFields()`

查询后重新发送请求

（后端接口问题，暂时无法实现）

```ts
>>user-content.vue
// 定义自定义事件
const emit = defineEmits(['queryClick', 'resetClick'])
//重置表单
const formRef = ref<InstanceType<typeof ElForm>>()
function handleResetClick() {
  // console.log(formRef.value)
  // 1.form中的数据全部重置
  formRef.value?.resetFields()
  // 2.将事件出去, content内部重新发送网络请求
  emit('resetClick')
}

>>user.vue


```



### 8.8. 删除某一条数据

需要监听到''某一条''数据的删除——作用域插槽 scope.raw.id

封装删除请求：service、store里依次封装

![image-20230608020108928](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230608020108928.png)

![image-20230608020140190](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230608020140190.png)

删除后需要自动更新——重新请求新数据

绑定事件



### 8.9. 新建用户的Modal 290——ing

- #### 点击新建按钮显示modal 

user-modal.vue组件

用el- dialog 对话框组件 + form完成布局

https://element-plus.gitee.io/zh-CN/component/dialog.html

默认不显示，当点击新建按钮才会显示modal（传递参数给兄弟组件）

`v-model="dialogVisible"`

`const dialogVisible = ref(true)`



- #### 选择角色、选择部门（有bug呜呜，）

用select选择器组件

需要先通过网络请求获取有哪些角色、部门

##### 0.模拟数据

##### 1.service>main>main.ts（因为很多页面都会用到）封装请求

```ts
/** 获取部门的信息 */
export function getDepartmentData(queryInfo: any) {
  return hyRequest.post({
    url: '/department/list',
    data: queryInfo
  })
}

/** 获取角色的信息 */
export function getRoleData(queryInfo: any) {
  return hyRequest.post({
    url: '/role/list',
    data: queryInfo
  })
}
```

##### 2.store新建`main.ts`存储部门、角色数据

###### vue报错EISDIR: illegal operation on a directory, read解决

###### Failed to fetch dynamically imported module

原因：引入system.ts时不能根据文件夹名字自动获取文件夹下的同名文件，需把路径写完整

![image-20230621111937429](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230621111937429.png)

##### 3.并在登录时（login.ts里）调用获取数据，刷新时重新请求



* #### 点击确定按钮, 创建数据



### 8.10. 编辑的Modal

- #### 编辑和新建用同一个modal组件

标题和表单内容

* #### 编辑的数据, 进行回显

获取点击的某一行的数据itemData 、 template  scope.raw.id

编辑弹窗modal表单内容formData根据itemData显示（密码除外 v-if）

编辑后数据会保留在新建modal里，需要清空

* #### 编辑操作网络请求

要传参数id，根据id修改数据库



## 九. 通用管理页面封装（高级组件）

### 9.1. 抽取网络请求 

前提：后端接口有一定规范

* 调用请求时传入pageName
* store
* service



### 9.2. 页面分为三个组件+配置，搭建部门管理页面

#### 9.2.1. PageSearch

* search.config.ts，内容由父组件传给子组件，defineProps

  ```ts
  >>page-search.vue
  // 定义props
  interface IProps {
    modalConfig: {
      pageName: string
      title: string
      formItems: any[]
    }
    otherInfo?: any
  }
  
  const props = defineProps<IProps>()
  
  >>department.vue
  <page-search :search-config="searchConfig"/>
  import searchConfig from './config/search.config'
  ```

  

* 遍历，表单有不同类型的项：

  可以用动态组件或者 v-if判断type，再来选择展示

  ```vue
  <template v-if="item.type === 'time'">
     <el-table-column
                align="center"
                :prop="item.prop"
                :label="item.label"
     >
         <template #default="scope">
             {{ utcFormat(scope.row[item.prop]) }}
         </template>
     </el-table-column>
  </template>
  ```



#### 9.2.2. PageContent

- 配置文件config

```ts
const contentConfig = {
  pageName: 'department',
  header: {
    title: '部门列表',
    btnTitle: '新建部门'
  },
  propsList: [
    { type: 'selection', label: '选择', width: 80 },
    { type: 'index', label: '序号', width: 60 },

    { type: 'normal', prop: 'name', label: '部门名称', width: 150 },
    { type: 'normal', prop: 'leader', label: '部门领导', width: 120 },
    { type: 'normal', prop: 'parentId', label: '上级部门', width: 90 },
    { type: 'time', prop: 'createAt', label: '创建时间' },
    { type: 'time', prop: 'updateAt', label: '更新时间' },
    { type: 'handler', label: '操作', width: 180 },
    {
      type: 'custom',
      prop: 'leader',
      label: '插槽自定义',
      width: 120,
      slotName: 'leader'
    }
  ]
}

export default contentConfig

```

* 插槽 => 作用于插槽 => 完全的定制化

  1.修改type，再增加一个template v-if（不够通用）

  2.template里使用具名插槽slot

  ```vue
  >>content.config.ts
  ...
  propsList: [
      ...
       {
        type: 'custom',
        prop: 'leader',
        label: '插槽自定义',
        width: 120,
        slotName: 'leader'
      }
    ]
  
  >>page-content.vue
  ...
  <template v-else-if="item.type === 'custom'">
     <el-table-column>
           <template #default="scope">//作用域插槽+具名插槽
                <slot :name="item.slotName" v-bind="scope" :prop="item.prop"></slot>
           </template>
     </el-table-column>
  </template>
  ...
  
  >>department.vue
  <page-content>
        <template #leader="scope">
          <span class="leader">++{{ scope.row[scope.prop] }}++ </span>
        </template>
  </page-content>
  
  //通过具名插槽可以实现自定义样式，普通遍历不能设置样式
  <style lang="less" scoped>
  .leader {
    color: red;
  }
  </style>
  
  ```

  scope干嘛的？（）



#### 9.2.3. PageModal

##### 配置文件:

* pageName

* header:（新建和编辑共用modal）
  * newTitle
  * editTitle
* formItems
  * el-form-item => el-input/el-select



##### 初始化值bug：307

默认是不展示的，所以设置的初始化值也没跟着渲染，后续点击显示的时候就不是初始化了

所以1.默认展示，2.改变展示时设置初始化值





##### 某些select的options数据来自服务器，配置文件时暂时空着

* modalConfig => mainStore => computed

  

### 9.3. 页面hooks抽取

setup相同逻辑抽取

* usePageContent
* usePageModal



### 9.4. 小bug的处理

* 多余的导入文件

* page-modal中，defineProps<不能来自文件引入>()

  Bug：使用setup语法糖代替setup函数的时候使用了defineProps，然而在定义类型的时候一旦将接口暴露出去引用就发生了报错，（defineProps以外可以用其他文件引入的类型）

  type argument passed to defineProps() must be a literal type, or a reference to an interface or literal type.

  原因：`defineProps` 或 `defineEmits` 要么使用运行时声明，要么使用类型声明。同时使用两种声明方式会导致编译报错。

  https://cn.vuejs.org/guide/typescript/composition-api.html#typing-component-props

  ![image-20230703185656084](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230703185656084.png)

  



## 十.快速搭建其他页面

#### 1 页面内容搭建：导入组件、写配置

#### 2 处理交互逻辑：导入hook、绑定事件

![image-20230703193956210](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230703193956210.png)

![image-20230703194044075](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230703194044075.png)

![image-20230703194020232](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230703194020232.png)

### 



## 十一. 其他页面的细节处理

### 11.1. 菜单管理（菜单树展开功能）

#### el-tabel——树形数据与懒加载

https://element-plus.gitee.io/zh-CN/component/table.html#%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%87%92%E5%8A%A0%E8%BD%BD

 当 row 中包含 `children` 字段时，被视为树形数据。 渲染嵌套数据需要 prop 的 `row-key`。

row-key最好不要直接写在组件模板里，应该在config文件里再加一段配置

```
childrenProps: {
    rowKey: 'id',
    treeProp: {
      children: 'children'
    }
  }
```



注意：config中不要给树形数据设置tpye，不然会覆盖树形折叠样式

![image-20230705162033818](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230705162033818.png)



![image-20230703194130094](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230703194130094.png)



### 11.2. 角色管理：（新建角色时分配菜单权限,菜单树）

#### PageModal自定义插槽

```vue
>>modal-config.ts
{
      type: 'custom',
      slotName: 'menulist'
}

>>page-modal.vue
<template v-if="item.type === 'custom'">
      <slot :name="item.slotName"></slot>
</template>

>>role.vue
<page-modal
      :modal-config="modalConfig"
      ref="modalRef"
      :other-info="otherInfo"
    >
      <template #menulist>
        <el-tree
          ref="treeRef"
          :data="entireMenus"
          show-checkbox
          node-key="id"
          highlight-current
          :props="{ label: 'name', children: 'children' }"
          @check="handleMenuCheckChange"
        />
      </template>
</page-modal>
```

#### 树形选择 tree树形控件

https://element-plus.gitee.io/zh-CN/component/tree.html

* 获取完整的菜单

  service封装方法，store 里调用获取数据

* 创建角色时, 携带选中的菜单id，传递给后端服务器
  
  otherInfo属性
  
  el-tree @check 两个参数 data1 data2
  
  ```ts
  //获取选中的菜单 id
  function handleMenuCheckChange(data1: any, data2: any) {
    const menuList = [...data2.checkedKeys, ...data2.halfCheckedKeys]
    otherInfo.value = { menuList } // 把 otherInfo传给 page-modal
    console.log(otherInfo)
  }
  ```
  
  
  
  ![image-20230706161312748](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230706161312748.png)



### 11.3. 角色管理：编辑角色数据回显菜单树

* mapMenuListToIds

  再写个工具，把菜单列表的 id 都取出来扁平化

* elTree.value?.setCheckKeys([])  （el 组件自带的方法）



####  nextTick（()=>{}）

回调是微任务

https://cn.vuejs.org/api/general.html#nexttick

当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。

* 使用场景

* 原理 promise.then(xxx)

* 源码![image-20230706225536492](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230706225536492.png)

  

### 11.4. 你的故事：富文本编辑器

https://www.wangeditor.com/

![image-20230706190948659](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230706190948659.png)



### 11.5. 核心技术：命令行tree 生成目录结构

![image-20230706193417127](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230706193417127.png)![image-20230706193427537](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230706193427537.png)![image-20230706193439048](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230706193439048.png)

### 11.6. 商品统计：echarts

![image-20230706193755044](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230706193755044.png)



### 3.1. 顶部数字的数据展示

* countup.js







### 3.2. Echarts图表的展示

* base-echart
* 各种图形
  * pie-echart
    * option => computed
  * rose-echart
  * line-echart
  * bar-echart
  * map-echart
* dashboard中获取数据
  * service
  * store
  * page







### 按钮权限控制

场景：没有权限时，不展示新建、编辑和删除按钮

##### 1.获取菜单时，映射权限：

utils封装方法 store 调用并存数据

##### 2.组件中按钮权限的判断逻辑：

组件开始时先判断权限，v-if 展示节点



抽到hook >usePermission.ts













## 四. Git的代码提交规范

### 4.1. husky对提供阶段拦截





### 4.2. 对message进行规范

* cz生成message的规范
* 不规范的lint限制

















# 项目打包和自动化部署

## 一. 项目部署和DevOps

### 1.1. 传统的开发模式

在传统的开发模式中，开发的整个过程是按部就班就行：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt2wf9lezj60xc0b40u102.jpg" alt="早期的开发模式" style="zoom:67%;" />

但是这种模式存在很大的弊端：

* 工作的不协调：开发人员在开发阶段，测试和运维人员其实是处于等待的状态。等到测试阶段，开发人员等待测试反馈bug，也会处于等待状态。
* 线上bug的隐患：项目准备交付时，突然出现了bug，所有人员需要加班、等待问题的处理；



### 1.2. DevOps开发模式

DevOps是Development和Operations两个词的结合，将开发和运维结合起来的模式：

![打开格局](https://tva1.sinaimg.cn/large/008i3skNgy1gtt32mnaj8j60k007ngmc02.jpg)

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt33f78kdj60fk0fkgmc02.jpg" alt="DevOps模式" style="zoom:67%;" />

### 1.3. 持续集成和持续交付

伴随着DevOps一起出现的两个词就是持续集成和持续交付(部署)：

* CI是Continuous Integration（持续集成）；
* CD是两种翻译：Continuous Delivery（持续交付）或Continuous Deployment（持续部署）；

持续集成CI：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt3bgnnvbj60rs0c8dgu02.jpg" alt="持续集成" style="zoom:67%;" />

持续交付和持续部署：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt3da1cd2j60rs0kkmz602.jpg" alt="持续交付" style="zoom:67%;" />

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtt3dtbewsj60rs0kk76a02.jpg" alt="持续部署" style="zoom:67%;" />

### 1.4. 自动化部署流程

![自动化部署的流程](https://tva1.sinaimg.cn/large/008i3skNgy1gtt5buus2kj60wu0lgq7002.jpg)



## 二. 购买云服务器

### 2.1. 注册阿里云的账号

云服务器我们可以有很多的选择：阿里云、腾讯云、华为云。

* 目前在公司使用比较多的是阿里云；
* 我自己之前也一直使用阿里云，也在使用腾讯云；
* 之前华为云也有找我帮忙推广他们的活动；

但是在我们的课程中，我选择目前使用更加广泛的阿里云来讲解：

我们需要注册阿里云账号

* https://aliyun.com/

* 注册即可，非常简单



### 2.2. 购买云服务器

购买云服务器其实是购买一个实例。

1.来到控制台：

![image-20201204152032769](https://tva1.sinaimg.cn/large/0081Kckwgy1glbumqekwhj31ct0p8grl.jpg)



2.创建实例，选择类型和配置

![image-20201204152133800](/Users/coderwhy/Library/Application Support/typora-user-images/image-20201204152133800.png)

![image-20201203103047329](/Users/coderwhy/Library/Application Support/typora-user-images/image-20201203103047329.png)

3.配置网络安全组

![image-20201203103725892](https://tva1.sinaimg.cn/large/0081Kckwgy1glagts0xxuj31at0nyq87.jpg)



4.创建实例

![image-20201203104249296](https://tva1.sinaimg.cn/large/0081Kckwgy1glagzdiwnpj31bk0o5433.jpg)



## 三. 搭建服务器环境

### 3.1. jenkins自动化部署

#### 3.1.1. 安装Java环境

Jenkins本身是依赖Java的，所以我们需要先安装Java环境：

* 这里我安装了Java1.8的环境

```shell
dnf search java-1.8
dnf install java-1.8.0-openjdk.x86_64
```



#### 3.1.2. 安装Jenkins

因为Jenkins本身是没有在dnf的软件仓库包中的，所以我们需要连接Jenkins仓库：

* wget是Linux中下载文件的一个工具，-O表示输出到某个文件夹并且命名为什么文件；
* rpm：全称为**The RPM Package Manage**，是Linux下一个软件包管理器；

```shell
wget –O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo

# 导入GPG密钥以确保您的软件合法
rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key
# 或者
rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key
```

编辑一下文件/etc/yum.repos.d/jenkins.repo

* 可以通过vim编辑

```
[jenkins]

name=Jenkins-stable

baseurl=http://pkg.jenkins.io/redhat

gpgcheck=1
```

安装Jenkins

```shell
dnf install jenkins # --nogpgcheck(可以不加)
```

启动Jenkins的服务：

```shell
systemctl start jenkins
systemctl status jenkins
systemctl enable jenkins
```

Jenkins默认使用8080端口提供服务，所以需要加入到安全组中：

![image-20201204173117359](https://tva1.sinaimg.cn/large/0081Kckwgy1glbyeoz6tqj315w0bzmzj.jpg)





#### 3.1.3. Jenkins用户

我们后面会访问centos中的某些文件夹，默认Jenkins使用的用户是 `jenkins`，可能会没有访问权限，所以我们需要修改一下它的用户：

修改文件的路径：`/etc/sysconfig/jenkins`

![image-20210825162827962](https://tva1.sinaimg.cn/large/008i3skNgy1gtt46oxg53j60n00aw75302.jpg)

之后需要重启一下Jenkins：

```shell
# 也可以将Jenkins添加到root组中
sudo usermod -a -G root jenkins

# 也可以给Jenkins目录权限
chown -R jenkins  /xxx/xxx 

systemctl restart jenkins
```



#### 3.1.4. 服务器需要安装git



#### 3.1.4. Jenkins配置

打开浏览器，输入：http://8.134.60.235:8080/

* 注意：你输入自己的IP地址

获取输入管理员密码：

* 在下面的地址中 `cat /var/lib/jenkins/secrets/initialAdminPassword`

![image-20201203173047824](/Users/coderwhy/Library/Application Support/typora-user-images/image-20201203173047824.png)

可以安装推荐的插件：

![安装推荐的插件](https://tva1.sinaimg.cn/large/0081Kckwgy1glbylb26ouj30fb082js7.jpg)



#### 3.1.5. Jenkins任务

**新建任务：**

![新建任务](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0uinjzej30pa0fet9z.jpg)

![image-20201204185613061](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0v225vaj30wl0hkn05.jpg)

**配置项目和保留策略：**

![image-20210825160744119](https://tva1.sinaimg.cn/large/008i3skNgy1gtt3l4fjm6j614p0d2dgl02.jpg)

**源码管理：**

![image-20210825160818122](https://tva1.sinaimg.cn/large/008i3skNgy1gtt3lpcvtgj614k0j8jsn02.jpg)

**构建触发器：**

这里的触发器规则是这样的：

* 定时字符串从左往右分别是：分 时 日 月 周

```js
#每半小时构建一次OR每半小时检查一次远程代码分支，有更新则构建
H/30 * * * *

#每两小时构建一次OR每两小时检查一次远程代码分支，有更新则构建
H H/2 * * *

#每天凌晨两点定时构建
H 2 * * *

#每月15号执行构建
H H 15 * *

#工作日，上午9点整执行
H 9 * * 1-5

#每周1,3,5，从8:30开始，截止19:30，每4小时30分构建一次
H/30 8-20/4 * * 1,3,5
```



![触发器](https://tva1.sinaimg.cn/large/008i3skNgy1gtt419gw6tj614g0agmy402.jpg)

**构建环境：**

注意：我们需要搭建Node的环境

* 第一步：配置Node的环境；
* 第二步：安装Node的插件；

![image-20201204190055096](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0zyecd4j31ar0ecjuz.jpg)

第一步：配置Node的环境

![node环境](https://tva1.sinaimg.cn/large/008i3skNgy1gtt42elwduj614h0elwfq02.jpg)

第二步：安装Node的插件

* 这里因为我已经安装过了，所以没有搜索到；

![image-20201204185949452](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0yta64bj30r907caam.jpg)



构建执行的任务：

* 查看Node的版本等是否有问题；
* 执行 `npm install` 安装项目的依赖；
* 移除原来mall_cms文件的所有内容；
* 将打包的dist文件夹内容移动到mall_cms文件夹；

```shell
pwd
node -v
npm -v

npm install 
npm run build

pwd

echo '构建成功'

ls

# 删除/root/mall_cms文件夹里所有的内容
rm -rf /root/mall_cms/* 

cp -rf ./dist/* /root/mall_cms/
```



![执行构建任务](https://tva1.sinaimg.cn/large/008i3skNgy1gtt43sz933j614o0dy0tk02.jpg)



### 3.2. nginx安装和配置

#### 3.2.1. 安装nginx

后续我们部署会使用nginx，所以需要先安装一下nginx：

```shell
dnf install nginx
```

启动nginx：

```shell
systemctl start nginx
systemctl status nginx
systemctl enable nginx
```



#### 3.2.2. 配置nginx

nginx配置文件所在目录

```
/etc/nginx/nginx.conf
```



我们这里主要配置nginx的用户和默认访问目录：

配置用户：

![image-20210825163329209](https://tva1.sinaimg.cn/large/008i3skNgy1gtt4bwvxc4j60f30453yk02.jpg)



通过Linux命令创建文件夹和文件：

```shell
mkdir /root/mall_cms
cd /root/mall_cms
touch index.html

vi index.html
```



配置访问目录：

![image-20210825163406566](https://tva1.sinaimg.cn/large/008i3skNgy1gtt4cka6hgj60n00bwgmc02.jpg)





# （其他：）

### GIT

https://github.com/July107/Vue3-TS-CMS/tree/master



#### 富文本编辑器

https://www.wangeditor.com/



## 接口文档

用fastmock代替coderwhy服务器的接口……

https://www.fastmock.site/#/project/046c9a86f344ac3742b8411ee508e233







接口文档v1版本：

https://documenter.getpostman.com/view/12387168/TzsfmQvw

baseURL的值：

```
http://152.136.185.210:5000
http://152.136.185.210:4000
```

设置全局token的方法：

```js
const res = pm.response.json();
pm.globals.set("token", res.data.token);
```

接口文档v2版本：（有部分更新）

https://documenter.getpostman.com/view/12387168/TzzDKb12



## BUG

#### 地址别名 @在 ts文件里有效，但在vue文件里无效

![image-20230515183454678](/Users/puluotagela/Library/Application Support/typora-user-images/image-20230515183454678.png)





#### 列表渲染菜单时，刷新浏览器丢失数据（

因为刷新时所有代码重新执行一次，但动态加载菜单路由是点击登录时才会被执行，所以再刷新时没有执行了

解决方法：在app.use（pinia）之后加载一下本地数据

```ts
>>store/index.ts
function registerStore(app: App<Element>) {
  // 1.use的pinia
  app.use(pinia)
  // 2.加载本地的数据
  const loginStore = useLoginStore()
  loginStore.loadLocalDataAction()
}
export default registerStore


>>main.ts
app.use(registerStore)
```

